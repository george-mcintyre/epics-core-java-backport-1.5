package org.epics.pvaccess.client.pvms;

import org.epics.pvaccess.PVAConstants;
import org.epics.pvaccess.impl.remote.SerializationHelper;
import org.epics.pvdata.misc.SerializeHelper;
import org.epics.pvdata.pv.Field;
import org.epics.pvdata.pv.PVField;
import org.epics.pvdata.pv.SerializableControl;
import org.epics.util.compat.jdk5.net.MulticastSocket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.util.Timer;
import java.util.TimerTask;

class PVMSPublisher extends PVMSCodec implements SerializableControl {

    private final MulticastSocket socket;
    private final DatagramPacket packet;

    private final ByteBuffer buffer = ByteBuffer.allocate(PVAConstants.MAX_UDP_PACKET);

    private final TimerTask timerTask;
    private boolean destroyed = false;

    /**
     * Outgoing (codes generated by this party) introspection registry that
     * always serializes with FULL_WITH_ID_TYPE_CODE.
     */
    private final OutgoingMulticastIntrospectionRegistry outgoingIR = new OutgoingMulticastIntrospectionRegistry();

    public PVMSPublisher(InetAddress sendAddress, int port) throws IOException {
        this(sendAddress, port, null, 0);
    }

    public PVMSPublisher(InetAddress sendAddress, int port, Timer timer, final int keepAlivePeriod) throws IOException {
        socket = new MulticastSocket();
        packet = new DatagramPacket(buffer.array(), 0, sendAddress, port);

        // optional feature; can not be used or manager by external code
        // by calling sendKeepAliveControlMessage() periodically
        if (timer != null && keepAlivePeriod > 0) {
            timerTask = new TimerTask() {
                @Override
                public void run() {
                    try {
                        synchronized (this) {
                            if (!destroyed)
                                sendKeepAliveControlMessage(keepAlivePeriod);
                        }
                    } catch (IOException e) {
                        // noop
                    }
                }
            };

            timer.schedule(timerTask, 0, keepAlivePeriod * 1000L);
        } else
            timerTask = null;
    }

    public void flushSerializeBuffer() {
        // TODO Auto-generated method stub
    }

    public void ensureBuffer(int size) {
    }

    public void alignBuffer(int alignment) {
        // TODO Auto-generated method stub
    }

    public void cachedSerialize(Field field, ByteBuffer buffer) {
        outgoingIR.serialize(field, buffer, this);
    }

    protected synchronized void sendShutdownControlMessage() throws IOException {
        buffer.clear();

        pmsShutdownControlMessage(buffer);

        packet.setLength(buffer.position());

        socket.send(packet);
    }

    protected synchronized void sendKeepAliveControlMessage(int expirationTimeSec) throws IOException {
        buffer.clear();

        pmsKeepAliveControlMessage(buffer, expirationTimeSec);

        packet.setLength(buffer.position());

        socket.send(packet);
    }

    private void pmsDataMessage(ByteBuffer buffer, String topicId, String[] tags, PVField data) {
        int messageSeqNo = incrementMessageSeqNum();

        udtDataHeader(buffer, messageSeqNo, PacketPosition.SOLO);

        // string topicID
        SerializeHelper.serializeString(topicId, buffer, this);

        // string[] tags
        if (tags.length == 0)
            SerializeHelper.writeSize(0, buffer, this);
        else {
            SerializeHelper.writeSize(tags.length, buffer, this);
            for (String tag : tags)
                SerializeHelper.serializeString(tag, buffer, this);
        }

        // Field + PVData
        if (data == null)
            SerializationHelper.serializeNullField(buffer, this);
        else {
            this.cachedSerialize(data.getField(), buffer);
            data.serialize(buffer, this);
        }
    }

    protected synchronized void sendData(String topicId, String[] tags, PVField data) throws IOException {
        buffer.clear();

        pmsDataMessage(buffer, topicId, tags, data);

        packet.setLength(buffer.position());

        socket.send(packet);
    }

    // TODO avoid auto-unboxing !!!
    // TODO cleanup
    // private final Map<String, Long> subscriptions = new HashMap<String, Long>();

    public void publishData(String topicId, String[] tags, PVField data) throws IOException {
        sendData(topicId, tags, data);
    }

    public synchronized void destroy() {
        if (destroyed)
            return;
        destroyed = true;

        if (timerTask != null)
            timerTask.cancel();

        try {
            sendShutdownControlMessage();
        } catch (IOException e) {
            // noop
        }

        // TODO do I need to wait a bit for shutdown message to be sent
        socket.close();
    }
}
